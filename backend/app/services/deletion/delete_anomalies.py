#!/usr/bin/env python3
"""
AI Shield - Anomaly File Deletion Script

This script is specifically designed to delete files identified as anomalies.
It handles permission elevation and creates a separate deletion script for execution.

Usage:
    python delete_anomalies.py [--threat-id ID] [--file-path PATH] [--all] [--dry-run]
"""

import os
import sys
import subprocess
import json
import argparse
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime
import logging

# Try to import send2trash for safe deletion
try:
    from send2trash import send2trash
    SEND2TRASH_AVAILABLE = True
except ImportError:
    SEND2TRASH_AVAILABLE = False
    print("[Warning] send2trash not installed - will use permanent deletion. Install with: pip install send2trash")

# Add backend to path (for app imports)
backend_dir = Path(__file__).parent.parent.parent.parent
sys.path.insert(0, str(backend_dir))

try:
    from app.store import DB, Threat
    from app.services import threat_actions
    from sqlmodel import Session
    DB_AVAILABLE = True
except ImportError as e:
    print(f"[Warning] Database not available: {e}")
    DB_AVAILABLE = False


def is_admin() -> bool:
    """Check if the script is running with administrator/elevated privileges."""
    try:
        if os.name == 'nt':  # Windows
            import ctypes
            return ctypes.windll.shell32.IsUserAnAdmin() != 0
        else:  # Linux/macOS
            return os.geteuid() == 0
    except Exception:
        return False


def request_admin_elevation(script_path: str) -> bool:
    """
    Request administrator/elevated privileges and re-run the script.
    
    Returns True if elevation was requested, False otherwise.
    """
    try:
        if os.name == 'nt':  # Windows
            import ctypes
            # Re-run the script with elevated privileges
            if not is_admin():
                print("[Admin] Requesting administrator privileges...")
                ctypes.windll.shell32.ShellExecuteW(
                    None,
                    "runas",  # Request elevation
                    sys.executable,
                    f'"{script_path}"',
                    None,
                    1  # SW_SHOWNORMAL
                )
                return True
        else:  # Linux/macOS
            if not is_admin():
                print("[Admin] Requesting root privileges...")
                # Re-run with sudo
                subprocess.run(['sudo', sys.executable, script_path] + sys.argv[1:])
                return True
    except Exception as e:
        print(f"[Error] Failed to request elevation: {e}")
    return False


def create_deletion_script(files_to_delete: List[Dict[str, str]], output_path: Optional[str] = None) -> str:
    """
    Create a separate Python script that will delete the specified anomaly files.
    
    Args:
        files_to_delete: List of dicts with 'path', 'threat_id', 'reason' keys
        output_path: Optional path for the deletion script
    
    Returns:
        Path to the created deletion script
    """
    if output_path is None:
        output_path = str(Path(__file__).parent / "delete_anomalies_executor.py")
    
    script_content = f'''#!/usr/bin/env python3
"""
AI Shield - Anomaly File Deletion Executor

This script was automatically generated by delete_anomalies.py
to delete identified anomaly files with elevated permissions.

Generated: {datetime.now().isoformat()}
Files to delete: {len(files_to_delete)}
"""

import os
import sys
import subprocess
import stat
from pathlib import Path
from typing import List, Dict, Any

# Files to delete
FILES_TO_DELETE = {json.dumps(files_to_delete, indent=2)}

def remove_readonly(func, path, exc_info):
    """Remove read-only attribute on Windows."""
    try:
        os.chmod(path, stat.S_IWRITE)
        func(path)
    except Exception:
        pass

def delete_file_safe(file_path: str) -> Dict[str, Any]:
    """Safely delete a file with proper permission handling - using proven working method."""
    result = {{
        "path": file_path,
        "success": False,
        "error": None,
        "method": None
    }}
    
    try:
        path = Path(file_path)
        
        if not path.exists():
            result["success"] = True
            result["method"] = "already_deleted"
            return result
        
        print(f"[Delete] Attempting to delete: {{file_path}}")
        
        # Method 1: Safe deletion using send2trash (Recycle Bin/Trash) - preferred method
        if SEND2TRASH_AVAILABLE:
            try:
                send2trash(str(path))
                # Note: send2trash moves to trash, so file may still exist at original location
                # but it's been moved to trash, which is considered successful
                result["success"] = True
                result["method"] = "send2trash_recycle_bin"
                print(f"[Delete] ✓ Success: File moved to Trash/Recycle Bin using send2trash")
                return result
            except Exception as e:
                print(f"[Delete] send2trash failed: {{e}}, trying other methods...")
        
        # Method 2: Normal deletion (permanent)
        try:
            os.remove(str(path))
            if not path.exists():
                result["success"] = True
                result["method"] = "file_removed"
                print(f"[Delete] ✓ Success: File permanently deleted using os.remove()")
                return result
        except PermissionError:
            print(f"[Delete] Permission denied with os.remove()")
        except Exception as e:
            print(f"[Delete] Error with os.remove(): {{e}}")
        
        # Method 2: Remove read-only and grant permissions (Windows)
        if os.name == 'nt':
            try:
                subprocess.run(['attrib', '-R', str(path)], check=False, capture_output=True, timeout=5)
                subprocess.run(['icacls', str(path), '/grant', 'Everyone:F'], check=False, capture_output=True, timeout=5)
                os.remove(str(path))
                if not path.exists():
                    result["success"] = True
                    result["method"] = "file_removed_after_permissions"
                    print(f"[Delete] ✓ Success: File deleted after fixing permissions")
                    return result
            except Exception as e:
                print(f"[Delete] Error with attrib/icacls: {{e}}")
        
        # Method 3: Use Windows batch script (Windows)
        if os.name == 'nt':
            try:
                script_dir = Path(__file__).parent
                batch_script = script_dir / "delete_file.bat"
                if batch_script.exists():
                    result_batch = subprocess.run(
                        ['cmd', '/c', str(batch_script), str(path)],
                        check=False,
                        capture_output=True,
                        timeout=10,
                        text=True
                    )
                    if not path.exists():
                        result["success"] = True
                        result["method"] = "windows_batch_script"
                        print(f"[Delete] ✓ Success: File deleted using Windows batch script")
                        return result
            except Exception as e:
                print(f"[Delete] Error with batch script: {{e}}")
        
        # Method 4: Use PowerShell script (Windows)
        if os.name == 'nt':
            try:
                script_dir = Path(__file__).parent
                ps_script = script_dir / "delete_file.ps1"
                if ps_script.exists():
                    result_ps = subprocess.run(
                        ['powershell', '-ExecutionPolicy', 'Bypass', '-File', str(ps_script), '-FilePath', str(path)],
                        check=False,
                        capture_output=True,
                        timeout=15,
                        text=True
                    )
                    if not path.exists():
                        result["success"] = True
                        result["method"] = "windows_powershell_script"
                        print(f"[Delete] ✓ Success: File deleted using PowerShell script")
                        return result
            except Exception as e:
                print(f"[Delete] Error with PowerShell script: {{e}}")
        
        # Method 5: PowerShell command (Windows)
        if os.name == 'nt':
            try:
                ps_cmd = f'Remove-Item -Path "{str(path)}" -Force'
                subprocess.run(['powershell', '-Command', ps_cmd], 
                             check=False, capture_output=True, timeout=10, shell=True)
                if not path.exists():
                    result["success"] = True
                    result["method"] = "elevated_deletion_powershell"
                    print(f"[Delete] ✓ Success: File deleted using PowerShell")
                    return result
            except Exception as e:
                print(f"[Delete] Error with PowerShell: {{e}}")
        
        # Method 6: CMD del command (Windows)
        if os.name == 'nt':
            try:
                subprocess.run(['del', '/f', '/q', str(path)], 
                             check=False, capture_output=True, timeout=5, shell=True)
                if not path.exists():
                    result["success"] = True
                    result["method"] = "elevated_deletion_cmd"
                    print(f"[Delete] ✓ Success: File deleted using CMD")
                    return result
            except Exception as e:
                print(f"[Delete] Error with CMD del: {{e}}")
        
        # Method 5: Take ownership and delete (Windows)
        if os.name == 'nt':
            try:
                subprocess.run(['takeown', '/f', str(path)], check=False, capture_output=True, timeout=5)
                subprocess.run(['icacls', str(path), '/grant', 'Everyone:F'], check=False, capture_output=True, timeout=5)
                os.remove(str(path))
                if not path.exists():
                    result["success"] = True
                    result["method"] = "force_deletion_takeown"
                    print(f"[Delete] ✓ Success: File deleted after taking ownership")
                    return result
            except Exception as e:
                print(f"[Delete] Error with takeown: {{e}}")
        
        # Linux/macOS methods
        if os.name != 'nt':
            try:
                os.chmod(str(path), stat.S_IWRITE | stat.S_IREAD | stat.S_IXUSR)
                os.remove(str(path))
                if not path.exists():
                    result["success"] = True
                    result["method"] = "file_removed_unix"
                    return result
            except Exception:
                pass
            
            # Try with sudo if available
            try:
                subprocess.run(['sudo', 'rm', '-f', str(path)], 
                             check=False, capture_output=True, timeout=10)
                if not path.exists():
                    result["success"] = True
                    result["method"] = "elevated_deletion_sudo"
                    return result
            except Exception:
                pass
        
        # Final verification
        if not path.exists():
            result["success"] = True
            result["method"] = "verified_deleted"
        else:
            result["error"] = "File still exists after all deletion attempts"
            print(f"[Delete] ✗ FAILED: All deletion methods failed. File still exists.")
            
    except Exception as e:
        result["error"] = str(e)
        print(f"[Delete] Exception: {{e}}")
    
    return result

def main():
    """Main execution function."""
    print("=" * 70)
    print("AI Shield - Anomaly File Deletion Executor")
    print("=" * 70)
    print(f"Files to delete: {{len(FILES_TO_DELETE)}}")
    print(f"Timestamp: {{datetime.now().isoformat()}}")
    print("=" * 70)
    print()
    
    results = []
    success_count = 0
    failure_count = 0
    
    for file_info in FILES_TO_DELETE:
        file_path = file_info.get("path", "")
        threat_id = file_info.get("threat_id", "unknown")
        reason = file_info.get("reason", "Anomaly detected")
        
        print(f"[{{threat_id}}] Deleting: {{file_path}}")
        print(f"         Reason: {{reason}}")
        
        result = delete_file_safe(file_path)
        result_with_meta = dict(result)
        result_with_meta["threat_id"] = threat_id
        result_with_meta["reason"] = reason
        results.append(result_with_meta)
        
        if result["success"]:
            print(f"         Status: ✓ Success ({{result['method']}})")
            success_count += 1
        else:
            print(f"         Status: ✗ Failed - {{result['error']}}")
            failure_count += 1
        print()
    
    # Summary
    print("=" * 70)
    print("Deletion Summary")
    print("=" * 70)
    print(f"Total files: {{len(FILES_TO_DELETE)}}")
    print(f"Successful: {{success_count}}")
    print(f"Failed: {{failure_count}}")
    print("=" * 70)
    
    # Save results
    results_file = Path(__file__).parent / "deletion_results.json"
    with open(results_file, 'w') as f:
        json.dump({{
            "timestamp": datetime.now().isoformat(),
            "total": len(FILES_TO_DELETE),
            "successful": success_count,
            "failed": failure_count,
            "results": results
        }}, f, indent=2)
    
    print(f"Results saved to: {{results_file}}")
    
    return 0 if failure_count == 0 else 1

if __name__ == "__main__":
    from datetime import datetime
    sys.exit(main())
'''
    
    # Write the script
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(script_content)
    
    # Make executable on Unix systems
    if os.name != 'nt':
        os.chmod(output_path, 0o755)
    
    return output_path


def get_anomaly_files_from_db(severity_filter: Optional[List[str]] = None, 
                               action_filter: Optional[List[str]] = None) -> List[Dict]:
    """
    Retrieve anomaly files from the database.
    
    Args:
        severity_filter: Filter by severity (e.g., ['high', 'critical'])
        action_filter: Filter by action (e.g., ['quarantined', None])
    
    Returns:
        List of threat dictionaries with file paths
    """
    if not DB_AVAILABLE:
        return []
    
    try:
        with Session(DB.engine) as s:
            threats = s.query(Threat).all()
            
            anomaly_files = []
            for threat in threats:
                # Filter by severity if specified
                if severity_filter and threat.severity not in severity_filter:
                    continue
                
                # Filter by action if specified
                if action_filter is not None:
                    if threat.action not in action_filter:
                        continue
                
                # Only include threats with file paths
                if threat.filePath:
                    anomaly_files.append({
                        "threat_id": threat.id,
                        "path": threat.filePath,
                        "severity": threat.severity,
                        "source": threat.source,
                        "description": threat.description,
                        "action": threat.action,
                        "reason": f"{threat.severity} severity threat from {threat.source}"
                    })
            
            return anomaly_files
    except Exception as e:
        print(f"[Error] Failed to query database: {e}")
        return []


def test_script_permissions() -> bool:
    """Test if the script has necessary permissions to delete files."""
    print("[Test] Testing script permissions...")
    
    # Test admin status
    admin_status = is_admin()
    print(f"[Test] Admin/Elevated privileges: {'Yes' if admin_status else 'No'}")
    
    # Test file system access
    try:
        test_file = Path(__file__).parent / ".permission_test"
        test_file.touch()
        test_file.unlink()
        print("[Test] File system access: OK")
        return True
    except Exception as e:
        print(f"[Test] File system access: FAILED - {e}")
        return False


def main():
    """Main function to delete anomaly files."""
    parser = argparse.ArgumentParser(
        description="Delete files identified as anomalies",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Delete all high/critical severity anomalies
  python delete_anomalies.py --all --severity high critical
  
  # Delete specific threat by ID
  python delete_anomalies.py --threat-id 123
  
  # Delete specific file
  python delete_anomalies.py --file-path /path/to/file.exe
  
  # Dry run (test without deleting)
  python delete_anomalies.py --all --dry-run
        """
    )
    
    parser.add_argument('--threat-id', type=int, help='Delete file for specific threat ID')
    parser.add_argument('--file-path', type=str, help='Delete specific file path')
    parser.add_argument('--all', action='store_true', help='Delete all anomaly files')
    parser.add_argument('--severity', nargs='+', choices=['low', 'medium', 'high', 'critical'],
                       default=['high', 'critical'], help='Filter by severity (default: high, critical)')
    parser.add_argument('--dry-run', action='store_true', help='Test without actually deleting files')
    parser.add_argument('--create-script-only', action='store_true', 
                       help='Only create deletion script, do not execute')
    
    args = parser.parse_args()
    
    print("=" * 70)
    print("AI Shield - Anomaly File Deletion Script")
    print("=" * 70)
    print()
    
    # Test script permissions
    if not test_script_permissions():
        print("[Warning] Permission test failed. Some files may not be deletable.")
        print()
    
    # Check admin status
    if not is_admin():
        print("[Warning] Not running with administrator/elevated privileges.")
        print("[Warning] Some files may require elevated permissions to delete.")
        print()
        response = input("Request administrator privileges? (y/n): ").strip().lower()
        if response == 'y':
            if request_admin_elevation(__file__):
                print("[Info] Elevation requested. Please approve in the UAC prompt.")
                return 0
    else:
        print("[Info] Running with administrator/elevated privileges.")
        print()
    
    # Collect files to delete
    files_to_delete = []
    
    if args.threat_id:
        # Delete specific threat
        if not DB_AVAILABLE:
            print("[Error] Database not available. Cannot query threat by ID.")
            return 1
        
        try:
            with Session(DB.engine) as s:
                threat = s.get(Threat, args.threat_id)
                if threat and threat.filePath:
                    files_to_delete.append({
                        "threat_id": threat.id,
                        "path": threat.filePath,
                        "reason": f"Threat ID {args.threat_id}: {threat.description}"
                    })
                else:
                    print(f"[Error] Threat {args.threat_id} not found or has no file path.")
                    return 1
        except Exception as e:
            print(f"[Error] Failed to query threat: {e}")
            return 1
    
    elif args.file_path:
        # Delete specific file
        if not Path(args.file_path).exists():
            print(f"[Error] File not found: {args.file_path}")
            return 1
        
        files_to_delete.append({
            "threat_id": "manual",
            "path": args.file_path,
            "reason": "Manually specified file path"
        })
    
    elif args.all:
        # Delete all anomalies
        if not DB_AVAILABLE:
            print("[Error] Database not available. Cannot query threats.")
            return 1
        
        files_to_delete = get_anomaly_files_from_db(
            severity_filter=args.severity,
            action_filter=[None, "quarantined"]  # Not yet deleted
        )
        
        if not files_to_delete:
            print("[Info] No anomaly files found matching criteria.")
            return 0
    
    else:
        parser.print_help()
        return 1
    
    if not files_to_delete:
        print("[Info] No files to delete.")
        return 0
    
    # Display files to be deleted
    print(f"Files to delete: {len(files_to_delete)}")
    print()
    for file_info in files_to_delete[:10]:  # Show first 10
        print(f"  - {file_info['path']} (ID: {file_info['threat_id']})")
    if len(files_to_delete) > 10:
        print(f"  ... and {len(files_to_delete) - 10} more")
    print()
    
    if args.dry_run:
        print("[Dry Run] No files will be deleted. This is a test run.")
        print()
        print("Files that would be deleted:")
        for file_info in files_to_delete:
            path = Path(file_info['path'])
            exists = path.exists()
            print(f"  {'✓' if exists else '✗'} {file_info['path']} ({'exists' if exists else 'not found'})")
        return 0
    
    # Confirm deletion (skip if running non-interactively or if --yes flag is set)
    if not args.create_script_only:
        # Auto-confirm in non-interactive mode (when called from API/service)
        # Only prompt if explicitly running from command line interactively
        try:
            import sys
            # Check if stdin is a TTY (interactive terminal)
            if hasattr(sys.stdin, 'isatty') and sys.stdin.isatty():
                # Only prompt if we have an actual interactive terminal
                try:
                    response = input(f"Delete {len(files_to_delete)} file(s)? (yes/no): ").strip().lower()
                    if response != 'yes':
                        print("[Cancelled] Deletion cancelled by user.")
                        return 0
                except (EOFError, KeyboardInterrupt):
                    # If input is interrupted, proceed anyway (non-interactive)
                    print(f"[Info] Auto-confirming deletion of {len(files_to_delete)} file(s)")
            else:
                # Non-interactive mode - auto-confirm
                print(f"[Info] Non-interactive mode: Auto-confirming deletion of {len(files_to_delete)} file(s)")
        except Exception:
            # If anything fails, assume non-interactive and proceed
            print(f"[Info] Auto-confirming deletion of {len(files_to_delete)} file(s)")
    
    # Create deletion script
    print("[Info] Creating deletion script...")
    script_path = create_deletion_script(files_to_delete)
    print(f"[Info] Deletion script created: {script_path}")
    print()
    
    if args.create_script_only:
        print("[Info] Script created. Execute it manually when ready.")
        print(f"[Info] Run: python {script_path}")
        return 0
    
    # Execute the deletion script
    print("[Info] Executing deletion script...")
    print()
    
    try:
        if os.name == 'nt':
            # Windows: Run with current Python interpreter
            result = subprocess.run([sys.executable, script_path], 
                                   capture_output=False, text=True)
        else:
            # Linux/macOS: Run with current Python interpreter
            result = subprocess.run([sys.executable, script_path], 
                                   capture_output=False, text=True)
        
        return result.returncode
    except Exception as e:
        print(f"[Error] Failed to execute deletion script: {e}")
        print(f"[Info] You can manually run: python {script_path}")
        return 1


if __name__ == "__main__":
    sys.exit(main())

